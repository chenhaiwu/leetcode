#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>

#define NODE_MAX 302
#define MAX(a, b) (a) > (b) ? (a) : (b)
#define MIN(a, b) (a) < (b) ? (a) : (b)
int g_pre[NODE_MAX];
int g_reginCnt[NODE_MAX];
// 记录某个连通分量中的病毒数
int g_regionVirusNum[NODE_MAX];
// 记录某个连通分量中第一个病毒，且只记一个
int g_regionVirsID[NODE_MAX];

int Find(int i)
{
    if (i != g_pre[i]) {
        g_pre[i] = Find(g_pre[i]);
    }
    return g_pre[i];
}

void Join(int i, int j)
{
    int pi = Find(i);
    int pj = Find(j);
    if (pi == pj) {
        return;
    } else if (pi < pj) {
        g_pre[pj] = pi;
    } else {
        g_pre[pi] = pj;
    }
    // for (int i = 0; i <= 24; i++) printf("%d ", g_pre[i]);
    // printf("\n");
}

void HanldeAllParnet(int len)
{
    for (int i = 0; i < len; i++) {
        Find(i);
    }
    // for (int i = 0; i <= 24; i++) printf("%d ", g_pre[i]);
    // printf("\n");
}

void InitParent(int** graph, int graphSize)
{
    for (int i = 0; i < graphSize; i++) {
        g_pre[i] = i;
        g_reginCnt[i] = 0;
        g_regionVirusNum[i] = 0;
    }
    for (int i = 0; i < graphSize; i++) {
        for (int j = 0; j < graphSize; j++) {
            if (graph[i][j] == 1) {
                Join(i, j);
            }
        }
    }
    for (int i = 0; i < graphSize; i++) {
        int t = Find(i);
        g_reginCnt[t]++;
    }
}

/* 并查集没有通过，原因在于这里的一个连通分量里，就找中只一个毒的，但是在这个连通分里里，并不是只删除一个结点可以得
有可能是在另外的一个连通分量里。 过了35/39个case，后面不好写，算了*/
int minMalwareSpread_unionFind(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize)
{
    int maxNum = 0;
    int id = INT_MAX;
    int cnt;
    InitParent(graph, graphSize);
    for (int i = 0; i < initialSize; i++) {
        int t = Find(initial[i]);
        g_regionVirusNum[t]++;
        g_regionVirsID[t] = initial[i];
    }
    for (int i = 0; i < initialSize; i++) {
        int delV = initial[i];
        // 统计所有的连通区
        cnt = 0;
        int devLP = Find(delV);
        for (int j = 0; j < graphSize; j++) {
            int curParent = Find(j);
            if (g_regionVirusNum[curParent] == 1 && g_regionVirsID[curParent] == delV) {
                cnt += g_reginCnt[curParent];
            }
        }
        if (cnt == maxNum) {
            id = MIN(id, delV);
        } else if (cnt > maxNum) {
            id = delV;
            maxNum = cnt;
        }        
    }
    // if (id == INT_MAX) {
    //     for (int i = 0; i < initialSize; i++) {
    //         id = MIN(id, initial[i]);
    //     }
    // }
    return id;
}

/* 写dfs 注意查找存储的是这个变量中，如果只中一个毒，则值为这个毒本身，如果中了多次，则值修改为-2. 初始值为-1
注意对象都是以某点中哪个毒为中心
*/
int g_visist[NODE_MAX];
int g_isbad[NODE_MAX];
int g_virusId[NODE_MAX];
int g_cntVirusNum[NODE_MAX];

#define DEGUG_CHW 1
void PrintArray(int* nums, int numsSize)
{
#ifdef DEGUG_CHW
    for (int i = 0; i < numsSize; i++) {
        printf("%d ", nums[i]);
    }
    printf("\n");
#endif
}

void dfs(int** graph, int graphSize, int virusID)
{
    for (int i = 0; i < graphSize; i++) {
        if (graph[virusID][i] == 1 && !g_isbad[i] && !g_visist[i]) {
            g_visist[i] = true;
            dfs(graph, graphSize, i);
        }
    }
}

int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize)
{
    if (initialSize == 1) {
        return initial[0];
    }
    for (int i = 0; i < graphSize; i++) {
        g_visist[i] = 0;
        g_virusId[i] = -1;
        g_cntVirusNum[i] = 0;
        g_isbad[i] = 0;
    }
    for (int i = 0; i < initialSize; i++) {
        g_isbad[initial[i]] = 1;
    }
    for (int i = 0; i < initialSize; i++) {
        memset(g_visist, 0x0, sizeof(g_visist));
        int virusID = initial[i];
        dfs(graph, graphSize, virusID);
        for (int j = 0; j < graphSize; j++) {
            if (g_virusId[j] == -2 || !g_visist[j]) {
                continue;
            }
            if (g_virusId[j] == -1) {
                g_virusId[j] = virusID;
            } else {
                g_virusId[j] = -2;
            }
        }
    }
    for (int i = 0; i < graphSize; i++) {
        int virusID = g_virusId[i];
        if (virusID >= 0) {
            g_cntVirusNum[virusID]++;
        }
    }
    PrintArray(g_cntVirusNum, graphSize);
    
    int maxNum = 0;
    int id = INT_MAX;
    for (int i = 0; i < graphSize; i++) {
        if (g_cntVirusNum[i] > maxNum) {
            maxNum = g_cntVirusNum[i];
            id = i;
        }
    }
    if (id == INT_MAX) {
        for (int i = 0; i < initialSize; i++) {
            id = MIN(id, initial[i]);
        }
    }
    return id;
}