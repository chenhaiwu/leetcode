题型总结：

1：贪心算法，每次都找最优解，则结果最优。可以考虑先排序，提速。

2：ABABAB，或者最大相同数字的排序，相同的数字不同相邻，可以有两种算法：
    1）：hash + qsort，每次模拟的办法，选次数最多的数字填到目标位置，然后再对hash数组进行排序，再选一个最大的，与上一次不同的。其实与上一次不相同，则选择第0个，如果相同，则选择第1个。
    2）：可以考虑不用排序，hash+奇偶填充位。先找到相同数字最多的数字及次数，然后从0,2,4,6开始填，注意一定填到最后一位还有没填的，否则不合法。然后再找下一个次数不为0的数，继续往偶数的后面填。然后把所有其它的数字往1,3,5这些位填。

3：桶排序：可以用于对所有的数字进行分组，如：给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。分析：连续的数字序列，则说明数字小的数一定后面得有k-1个数。这样可以对k进行求模，每个值就是一个桶，把所有的这些数，按模分到桶里去。这样桶里的元素个数，一定为numsSize / k ，如果不相等，则一定错误。

4：归并排序。写法：递归 + 合并元素到临时队列，再把临时队列拷到原始队列。经常使用归并排序用于来求解连续的i->j的数组的个数。区间合个数，或者逆序对。 
例如leetcode 315题：右面小于当前元素的个数，计算left区间，每出一个元素，right区间中比当前这个出的元素小的个数 = (j-mid-1)，然后记得是索引值，给每个索引，增加计数器值。
及327：统计区间个数：left -> right区间，right区间弄两个start/end指针，则找到end, start之间有多少个，即可区间个数。
leet493: 统计 可以，先归并排序，然后在left/right区间中，从left的第一个元素开始，与right的第一个元素比较 ，是否符合2位的条件 ，如果是则left的整个区间从i到最后一个元素都符合条件(mid - left_i + 1) 且right_j++，
如果不符合条件，则left_i ++
5: 快速排序中的快速查找，分区查找，可以实现o(n)的时间复杂度，找到数组中第k大的值，注意快排的思路，弄一个哨兵。是查找位置的概念
6: 序列型dp问题，注意查找前面一个可以有效的工作。leet1235.
7: 并查集如何检查是否有环，可以先定义总计数值，然后每次两个点之间检查一下父亲结点，如果不是同一个父亲，则计数--，然后修改当前的父子关系
    查找所有的边的两点关系，然后检查减后的计数值，如果是1，则表示无环，如果有环的话，这个值一定大于1.
    用于题型：冗余连接
8:二分查找，写法：while (left <= right) {注意更新 left = mid + 1; right = mid - 1}; 退出表示没有找到。
9：背包问题：如果要选价值最大的，初始化时把所有的数据全部初始化为0，如果是选重量恰好为m的，则只需要把0个元素初始化为0，其它元素初始化为负无穷大，需要枚举个最大值。
            如果使用二维数组保存数据，则需要选 dp[n][0->m]价值最大的。
            dp[i][j]：表示前i个物品，空间为j的价值最大值。
            递推公式：dp[i][j] = max{dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]}，选与不选的最大值
    0/1背包问题，优化时：第i个物品，从小到大枚举。容积从大到小枚举，可以使用一维空间。
    完全背包问题，优化时：物品从小到大，容积选择从小到大枚举。
    https://www.cnblogs.com/DreamInPal/p/11560782.html
10:买卖股票的问题模板
11：小偷劫舍的问题，动态规划或者记忆化查找。
12: Bfs时，一定要注意，如果有解答错误，那极有可能是queue的长度太小导致。
13: 全局变量先都使用memset，全部空间，通过后再优化，因为数据有可能没清零好，导致解答错误。

